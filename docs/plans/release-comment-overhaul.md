# Release Plan PR Comment Overhaul

## Context

The current PR release plan comment (`pr.yml` lines 265-350) is a flat markdown table generated by inline JavaScript in a GitHub Actions workflow. It shows package names, PR versions, kind, and commit counts â€” but lacks:

- Interactivity (publish triggers)
- Structural insight (cascade attribution, version projections)
- Navigability (links to source, commits, registry)
- Visualization (tree view)
- State management (publish status tracking)

This plan redesigns the comment as a rich nested list with checkboxes, moves generation logic into the release package CLI, and adds a publish-via-checkbox workflow. Organized in two waves across 5 layers.

## Architecture: Wave/Layer Dependency Graph

```
Wave 1:
  L1 API Data â”€â”€> L2 API Printers â”€â”€> L3 CLI
  L4 CI Actions (parallel with L1-L3, consumes L3 output)

Wave 2:
  L5 JSON Pipeline (extends L3, refactors L4)
```

### Post-Refactor Architecture (Analyzer â†’ Planner â†’ Executor)

The release API was restructured into a four-stage pipeline. All paths below are relative to `packages/release/src/api/`.

```
analyzer/          â†’ Expensive analytical core (scan, impacts, cascades, tags)
  models/
    analysis.ts    â†’ Analysis { impacts, cascades, unchanged, tags }
    impact.ts      â†’ Impact { package, bump, commits, currentVersion }
    cascade-impact.ts â†’ CascadeImpact { package, triggeredBy: Package[], currentVersion }
  analyze.ts       â†’ analyze() orchestrator
  cascade.ts       â†’ buildDependencyGraph()
  version.ts       â†’ extractImpacts, aggregateByPackage, findLatestTagVersion, findLatestPrNumber
  commit.ts        â†’ ReleaseCommit (extends Git.ParsedCommit)
  prerelease.ts    â†’ PrPrerelease, PreviewPrerelease schemas
  workspace.ts     â†’ Package scanning

planner/           â†’ Lightweight version projection (consumes Analysis)
  models/
    plan.ts        â†’ Plan { type, timestamp, releases, cascades, analysis? }
    item.ts        â†’ Item = Stable | Preview | Pr
    item-pr.ts     â†’ Pr { package, prerelease, commits }
    item-stable.ts â†’ Stable { package, version, commits }
    stable-version.ts â†’ StableVersionFirst | StableVersionIncrement
  cascade.ts       â†’ detect() (BFS, builds Stable cascade items)
  pr.ts            â†’ pr(analysis, ctx) â†’ Plan
  stable.ts        â†’ stable(analysis, ctx) â†’ Plan
  preview.ts       â†’ preview(analysis, ctx) â†’ Plan
  presentation.ts  â†’ renderPlan(), renderStatus(), etc.
  version.ts       â†’ calculateNextVersion, calculatePrVersion
  resource.ts      â†’ plan.json read/write

explorer/          â†’ Environment reconnaissance
  models/
    recon.ts       â†’ Recon { ci, github: { target: GitIdentity, credentials }, npm, git: { branch } }
    git-identity.ts â†’ GitIdentity { owner, repo, source }
  explore.ts       â†’ explore() â†’ Recon

executor/          â†’ Durable workflow execution via @kitz/flo
  workflow.ts      â†’ Release DAG: Preflight â†’ Publish â†’ CreateTag â†’ PushTag â†’ CreateGHRelease
```

### Key Existing Capabilities (reusable as-is)

> **@claude:** These are the "existing entities" to build on. The refactor already provides most of Layer 1's data needs.

| Need                        | Already Exists                           | Location                            |
| --------------------------- | ---------------------------------------- | ----------------------------------- |
| Cascade "via" attribution   | `CascadeImpact.triggeredBy: Package[]`   | `analyzer/models/cascade-impact.ts` |
| Analysis embedded in Plan   | `Plan.withAnalysis()` + `plan.analysis?` | `planner/models/plan.ts`            |
| GitHub owner/repo           | `Recon.github.target: GitIdentity`       | `explorer/models/git-identity.ts`   |
| Git branch                  | `Recon.git.branch`                       | `explorer/models/recon.ts`          |
| Commit per-scope extraction | `ReleaseCommit.forScope(scope)`          | `analyzer/commit.ts`                |
| Version projection          | `calculateNextVersion()`                 | `planner/version.ts`                |
| Current stable version      | `Impact.currentVersion`                  | `analyzer/models/impact.ts`         |
| Bump type per package       | `Impact.bump`                            | `analyzer/models/impact.ts`         |
| Dependency graph            | `buildDependencyGraph()`                 | `analyzer/cascade.ts`               |
| Moniker display name        | `Moniker.moniker` getter                 | `@kitz/pkg`                         |

---

## Wave 1

### Layer 1: API Data Gathering

**Goal:** Build a `CommentData` type that projects the Plan + Analysis + Recon into everything the renderers need.

> **@claude:** The refactor eliminated most of the original Layer 1 work. `CascadeImpact.triggeredBy` provides "via" attribution for free. `Plan.analysis` embeds the full Analysis. `Explorer.explore()` provides GitHub identity. What remains is: (1) a projection function that maps these to display types, (2) stable version projection for PR items, (3) publish history from comment state.

#### 1a. CommentData type

**New file:** `packages/release/src/api/planner/comment-data.ts`

> **@claude:** Lives under `planner/` (not `plan/` â€” that old path no longer exists). This is a presentation-adjacent module: it transforms Plan data into a rendering-ready shape.

```typescript
interface GitHubContext {
  readonly owner: string
  readonly repo: string
  readonly branch: string
  readonly headSha: string
  readonly prNumber: number
}

interface CommentData {
  readonly plan: Plan
  readonly github: GitHubContext
  readonly releases: readonly EnrichedRelease[]
  readonly cascades: readonly EnrichedCascade[]
}

interface EnrichedRelease {
  readonly item: Item
  readonly commits: readonly CommitDisplay[]
  readonly stableProjection: StableProjection
  readonly publishedVersions: readonly PublishRecord[]
  readonly sourceUrl: string
}

interface EnrichedCascade {
  readonly item: Item
  readonly via: readonly string[] // primary package moniker(s) that triggered this
  readonly sourceUrl: string
}

interface CommitDisplay {
  readonly shortSha: string // 7-char hash
  readonly subject: string // CC description
  readonly type: string // feat, fix, chore, etc.
  readonly breaking: boolean
  readonly commitUrl: string // https://github.com/{owner}/{repo}/commit/{sha}
}

interface StableProjection {
  readonly version: Semver.Semver // what stable version would be if merged
  readonly bump: Semver.BumpType // minor, patch, major
  readonly current: Option<Semver.Semver>
}
```

#### 1b. Cascade "via" attribution

> **@claude:** Already solved. `Analysis.cascades` is `CascadeImpact[]`, and each `CascadeImpact` has `triggeredBy: Package[]`. The `enrichPlan()` function reads this directly from `plan.analysis.cascades` â€” no BFS, no new function, no `computeViaMap()`.

**Source:** `plan.analysis.cascades` â†’ match each cascade item by package name â†’ extract `triggeredBy[].name.moniker` â†’ populate `EnrichedCascade.via`.

#### 1c. Stable version projection

**Reuse existing:** `calculateNextVersion()` from `planner/version.ts` and `Impact.currentVersion` + `Impact.bump` from `plan.analysis.impacts`.

For each PR plan item:

1. Find matching impact in `plan.analysis.impacts` by package name
2. Read `impact.currentVersion` and `impact.bump`
3. Call `calculateNextVersion(impact.currentVersion, impact.bump)` â†’ projected stable

Pure computation, all inputs already in `plan.analysis`.

#### 1d. Published PR version history

**Source: PR comment JSON data only.** Git tags are unsuitable (PR branches get force-pushed, tags would pollute the repo). npm registry queries add latency and complexity. Instead, the PR comment itself stores publish history as structured JSON in an HTML comment.

**Format in the comment body:**

```html
<!-- kitz-release-publish-history
{"publishes":[{"version":"0.0.0-pr.129.1.abc1234","iteration":1,"sha":"abc1234","timestamp":"2026-02-14T12:00:00Z","runId":"12345678"}]}
-->
```

**Lifecycle:**

1. Comment is first created by `pr.yml` â†’ no publish history (empty array)
2. User checks checkbox â†’ `publish-pr.yml` runs â†’ on success, appends to the JSON
3. New push triggers `pr.yml` â†’ comment is regenerated, but the workflow reads the existing comment's publish history BEFORE overwriting, and preserves it in the new comment
4. The `--comment` renderer receives `publishedVersions` and renders them with links

**Data shape:**

```typescript
interface PublishRecord {
  readonly version: string
  readonly iteration: number
  readonly sha: string
  readonly timestamp: string // ISO date of publish
  readonly runId: string // GH Actions run ID for traceability
}
```

**Reading publish history (in pr.yml):**
Before generating the new comment, the workflow reads the existing comment body (if any), extracts the JSON, and passes it to the CLI as a file:

```yaml
- name: Extract existing publish history
  uses: actions/github-script@v7
  id: history
  with:
    script: |
      // Find existing comment, extract <!-- kitz-release-publish-history ... -->
      // Write to /tmp/publish-history.json

- name: Generate comment
  run: |
    node cli.js plan pr --comment \
      --publish-history /tmp/publish-history.json \
      > /tmp/comment.md
```

**Writing publish history (in publish-pr.yml):**
After successful publish, append the new publish record to the JSON and update the comment.

#### 1e. enrichPlan function

> **@claude:** This is now much simpler than originally planned. Most inputs come directly from `plan.analysis` (which is always populated via `Plan.withAnalysis()` in the planner). The function is a pure projection.

```typescript
const enrichPlan: (
  plan: Plan,
  context: {
    github: GitHubContext
    publishHistory: readonly PublishRecord[] // from existing PR comment, or empty
  },
) => CommentData
```

Reads from `plan.analysis`:

- `analysis.impacts` â†’ commits, bump, currentVersion per package
- `analysis.cascades` â†’ `triggeredBy` for each cascade
- `analysis.tags` â†’ not needed (publish history comes from comment JSON)

Builds `CommitDisplay[]` per release using `ReleaseCommit.forScope()`.
Builds `StableProjection` per release using `Impact.bump` + `calculateNextVersion()`.
Builds `EnrichedCascade.via` from `CascadeImpact.triggeredBy`.

#### 1f. GitHubContext resolver

> **@claude:** The `Explorer.explore()` function already provides most of this via `Recon`. But `explore()` requires `GITHUB_TOKEN` (calls `resolveGithubToken`). For comment generation we only need owner/repo/branch â€” no token needed. Two options: (1) make `explore()` token-optional, or (2) build a lighter resolver. Option 2 is cleaner â€” comment rendering shouldn't depend on credentials.

**New function** in `comment-data.ts`:

```typescript
const resolveGitHubContext: (
  prNumber: number,
) => Effect<GitHubContext, ExplorerError, Git.Git | Env.Env>
```

Internally:

- Reuses `resolveReleaseTarget()` from `explorer/explore.ts` (extracted â€” it's currently a local function, may need to be exported)
- Gets branch from `git.getCurrentBranch()` (or fallback from env)
- Gets headSha from `git.getHeadSha()`
- Does NOT call `resolveGithubToken()`

---

### Layer 2: API Printers

**Goal:** Two renderers consuming `CommentData`, producing string output.

#### 2a. Markdown comment renderer

**New file:** `packages/release/src/api/planner/render-comment.ts`

```typescript
interface CommentRenderOptions {
  readonly publishState?: 'idle' | 'publishing' | 'published' | 'failed'
}

const renderComment: (
  data: CommentData,
  options?: CommentRenderOptions,
) => string
```

**Output structure:**

````markdown
<!-- kitz-release-plan -->
<!-- head-sha:959738bc -->
<!-- publish-state:idle -->
<!-- kitz-release-publish-history
{"publishes":[]}
-->

## Release Plan Preview

37 packages Â· 33 primary Â· 4 cascades Â· head [`959738b`](commit-link)

<details><summary>How release calculation works</summary>

**Primary** â€” packages with commits directly touching their source in this PR.
**Cascade** â€” packages that depend on a primary release; re-published for consistency.

| Context | Version Format                        | Example                  |
| ------- | ------------------------------------- | ------------------------ |
| PR      | `0.0.0-pr.<pr>.<iter>.<sha>`          | `0.0.0-pr.129.1.959738b` |
| Stable  | Semver bump from conventional commits | `0.2.0`                  |

Bump rules: `feat()` â†’ minor Â· `fix()` â†’ patch Â· `!` â†’ major
Cascades inherit patch bump.

</details>

---

### Primary (33)

- [ ] [ðŸ“‚](source-link) **@kitz/test** â€” 35 commits
      [`a1b2c3d`](cl) [`b2c3d4e`](cl) [`c3d4e5f`](cl) [`d4e5f6g`](cl) [`e5f6g7h`](cl) +30
      `0.0.0-pr.129.2.959738b` â†’ merged: **`0.2.0`** minor
      published: [**`pr.129.2.959738b`**](npm) Â· [`pr.129.1.abc1234`](npm)

- [ ] [ðŸ“‚](source-link) **@kitz/paka** â€” 20 commits
      [`f6g7h8i`](cl) [`g7h8i9j`](cl) +18
      `0.0.0-pr.129.2.959738b` â†’ merged: **`0.1.0`** minor

...

### Cascades (4)

- [ ] [ðŸ“‚](source-link) **@kitz/assert** via `core` â€” 5 commits
      [`k1l2m3n`](cl) +4
      `0.0.0-pr.129.2.959738b` â†’ merged: **`0.1.0`** patch

...

<details><summary>Tree</summary>

```text
(tree viz output from renderTree)
```
````

</details>
```

**Sub-functions:**

- `renderReleaseItem(release: EnrichedRelease): string`
- `renderCascadeItem(cascade: EnrichedCascade): string`
- `renderCommitShas(commits: CommitDisplay[], max: number): string` â€” inline SHAs with `+N` overflow
- `renderPublishedVersions(versions: PublishRecord[], registryBase: string): string` â€” latest bold, rest dimmer
- `renderMetadata(github: GitHubContext, state: string): string` â€” HTML comments
- `renderExplainer(): string` â€” the details toggle content

Uses `Str.Builder()` from `@kitz/core` following existing pattern in `planner/presentation.ts`.

**Sorting:** Releases sorted by commit count descending (most activity first).

**Commit SHA display:** Max 5 inline, each linked to `https://github.com/{owner}/{repo}/commit/{sha}`. Overflow shown as `+N`.

**Published versions:** Latest iteration bold + checkmark, older iterations plain. Each linked to `https://www.npmjs.com/package/{name}/v/{version}`.

#### 2b. Tree visualization renderer

**New file:** `packages/release/src/api/planner/render-tree.ts`

```typescript
const renderTree: (data: CommentData) => string
```

**Output:**

```text
kitz release plan preview Â· 37 packages
â”œâ”€ primary (33)
â”‚  â”œâ”€ @kitz/test Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· 35 commits  a1b2c3d feat(test): add snapshot mode
â”‚  â”œâ”€ @kitz/paka Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· 20 commits  f6g7h8i refactor(paka): resolver
â”‚  â”œâ”€ @kitz/fs Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· 19 commits  i9j0k1l feat(fs): path combinators
â”‚  â”‚  ... 28 more
â”‚
â””â”€ cascades (4)
   â”œâ”€ @kitz/assert Â·Â·Â·Â·Â·Â·Â·Â·Â· via core
   â”œâ”€ @kitz/conf Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· via core
   â”œâ”€ @kitz/monorepo Â·Â·Â·Â·Â·Â·Â· via paka
   â””â”€ @kitz/pkg Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· via paka
```

Box-drawing with `â”œâ”€`, `â””â”€`, `â”‚`. Dot-leaders for column alignment. Primary items sorted by commit count desc. Shows latest commit hash + subject inline. Top N items shown (configurable, default 5), rest collapsed as `... N more`.

#### 2c. Module exports

**Modify:** `packages/release/src/api/planner/__.ts` â€” add exports:

```typescript
export * from './comment-data.js'
export * from './render-comment.js'
export * from './render-tree.js'
```

---

### Layer 3: CLI

**Goal:** Expose printers via CLI flags on the `plan` command.

**Modify:** `packages/release/src/cli/commands/plan.ts`

#### 3a. New flags

```typescript
.parameter(
  'comment',
  Schema.UndefinedOr(Schema.Literal(true)).pipe(
    Schema.annotations({ description: 'Output PR comment markdown to stdout' }),
  ),
)
.parameter(
  'viz',
  Schema.UndefinedOr(Schema.Literal('tree')).pipe(
    Schema.annotations({ description: 'Output tree visualization to stdout' }),
  ),
)
.parameter(
  'publish-history',
  Schema.UndefinedOr(Schema.String).pipe(
    Schema.annotations({ description: 'Path to JSON file with publish history (from existing PR comment)' }),
  ),
)
```

#### 3b. Command flow with new flags

> **@claude:** The current command already calls `Api.Analyzer.analyze()` and `Api.Planner.pr(analysis, ctx)`. The analysis is available. The Plan already embeds it via `Plan.withAnalysis()`. So the enrichment step just reads from `plan.analysis`.

After existing plan generation + plan.json write:

```typescript
if (args.comment || args.viz) {
  const prNumber = detectPrNumber(env.vars) ?? 0
  const github = yield * Api.Planner.resolveGitHubContext(prNumber)

  // Read publish history from file if provided
  const publishHistory = args.publishHistory
    ? JSON.parse(yield * Fs.readString(Fs.Path.fromString(args.publishHistory)))
    : []

  const commentData = Api.Planner.enrichPlan(plan, {
    github,
    publishHistory,
  })

  if (args.comment) {
    yield * Console.log(Api.Planner.renderComment(commentData))
  }
  if (args.viz === 'tree') {
    yield * Console.log(Api.Planner.renderTree(commentData))
  }
}
```

**Key:** `--comment` and `--viz` both write plan.json AND produce their output. The plan file is always written as a side effect. The enriched output goes to stdout.

---

### Layer 4: CI Action Abstractions

**Goal:** Extract reusable CI building blocks, wire up the publish-via-checkbox workflow.

#### 4a. PR comment upsert composite action

**New file:** `.github/actions/upsert-pr-comment/action.yaml`

**Inputs:**

- `file` (required) â€” path to markdown file
- `marker` (required, default: `<!-- kitz-release-plan -->`) â€” HTML comment marker
- `github-token` (optional, default: `${{ github.token }}`)

**Logic:** Find existing bot comment with marker â†’ update or create. Direct extraction of `pr.yml` lines 312-350.

#### 4b. Refactored `pr.yml` release-plan-comment job

Replace inline JS (lines 265-311) with CLI call:

```yaml
# Extract publish history from existing comment (if any)
- name: Extract publish history
  uses: actions/github-script@v7
  id: history
  with:
    script: |
      const marker = '<!-- kitz-release-plan -->'
      const { owner, repo } = context.repo
      const issue_number = context.issue.number
      const comments = await github.paginate(github.rest.issues.listComments, {
        owner, repo, issue_number, per_page: 100,
      })
      const existing = comments.find(c =>
        c.user?.type === 'Bot' && c.body?.includes(marker)
      )
      const match = existing?.body?.match(
        /<!-- kitz-release-publish-history\n(.*?)\n-->/s
      )
      const history = match ? match[1] : '{"publishes":[]}'
      require('fs').writeFileSync('/tmp/publish-history.json', history)

- name: Generate release plan comment
  env:
    GITHUB_PR_NUMBER: ${{ github.event.pull_request.number }}
  run: |
    node packages/release/build/cli/cli.js plan pr --comment \
      --publish-history /tmp/publish-history.json \
      > /tmp/release-plan-comment.md

- uses: ./.github/actions/upsert-pr-comment
  with:
    file: /tmp/release-plan-comment.md
```

#### 4c. Publish PR workflow

**New file:** `.github/workflows/publish-pr.yml`

**Trigger:** `issue_comment` type `edited`

**Gate conditions (in order):**

1. Comment is on a PR (not an issue): `github.event.issue.pull_request`
2. Comment contains release plan marker: `contains(body, '<!-- kitz-release-plan -->')`
3. Publish state is `idle` or `failed` (parsed from `<!-- publish-state:... -->`)
4. At least one checkbox is checked: regex `- \[x\]`

**Publish scope:** Checking ANY checkbox publishes ALL packages (monorepo interdependencies require atomic publish).

**State machine:**

```
idle â”€â”€[any checkbox checked]â”€â”€> publishing
publishing â”€â”€[success]â”€â”€> published
publishing â”€â”€[failure]â”€â”€> failed
failed â”€â”€[any checkbox checked]â”€â”€> publishing (retry)
any â”€â”€[new push triggers pr.yml re-plan]â”€â”€> idle (comment fully regenerated)
```

**Steps:**

1. Detect checkbox change + parse metadata (head-sha, publish-state)
2. Update comment body: `publish-state:publishing` + status banner
3. Checkout PR head at `head-sha` from metadata
4. Build @kitz/release
5. `plan pr` + `apply --yes` (publishes ALL packages)
6. On success: update comment â†’ `publish-state:published`, checkboxes â†’ `[x]`, append publish record to history JSON, re-render comment with npm links
7. On failure: update comment â†’ `publish-state:failed`, add error link to workflow run

**Permissions:** `contents: write`, `pull-requests: write`
**Secrets:** `NPM_TOKEN` for npm publish

#### 4d. Comment metadata format

Embedded as HTML comments in the markdown body:

```html
<!-- kitz-release-plan -->
<!-- head-sha:959738bc -->
<!-- publish-state:idle -->
<!-- kitz-release-publish-history
{"publishes":[]}
-->
```

**New file:** `packages/release/src/api/planner/comment-metadata.ts`

```typescript
interface CommentMetadata {
  readonly headSha: string
  readonly publishState: 'idle' | 'publishing' | 'published' | 'failed'
  readonly publishHistory: readonly PublishRecord[]
}

const parseMetadata: (body: string) => CommentMetadata | null
const embedMetadata: (body: string, metadata: CommentMetadata) => string
```

Used by both the render step (embedding) and the publish workflow (parsing).

---

## Wave 2

### Layer 5: CI CLI Automation (JSON Pipeline)

**Goal:** Decouple data generation from presentation via structured JSON. CI becomes: `plan --json | render comment`.

#### 5a. `plan --json` flag

**Modify:** `packages/release/src/cli/commands/plan.ts`

```typescript
.parameter(
  'json j',
  Schema.UndefinedOr(Schema.Literal(true)).pipe(
    Schema.annotations({ description: 'Output enriched plan as JSON to stdout' }),
  ),
)
```

**Behavior:** When `--json` is set:

1. Generate plan (normal)
2. Write plan.json (normal)
3. Enrich plan into `CommentData`
4. Serialize `CommentData` to JSON (define a Schema for it)
5. Print to stdout
6. Skip human-readable output

The JSON output is the **enriched** data (CommentData), not raw plan.json. This gives consumers everything they need for rendering.

#### 5b. `render` CLI command

**New file:** `packages/release/src/cli/commands/render.ts`

```
release render <format> [--from-file <path>]
```

- `format`: `comment` | `tree` | `plan` (human-readable)
- `--from-file`: read enriched JSON from file (otherwise reads stdin)

**Flow:**

1. Read JSON string (file or stdin)
2. Decode to `CommentData` via Schema
3. Call appropriate renderer
4. Print to stdout

**Effect layers:** Minimal â€” `Env.Live`, `NodeFileSystem.layer` only. No `Git.Git` needed (all data comes from JSON input).

#### 5c. Refactored CI pipeline (Wave 2 version)

```yaml
# Step 1: Generate enriched plan JSON
- run: node cli.js plan pr --json > /tmp/enriched-plan.json

# Step 2: Render comment from JSON
- run: node cli.js render comment --from-file /tmp/enriched-plan.json > /tmp/comment.md

# Step 3: Upsert comment
- uses: ./.github/actions/upsert-pr-comment
  with:
    file: /tmp/comment.md
```

**Benefits:**

- Plan generation is testable independently from rendering
- Comment rendering is testable with fixture JSON files
- New output formats just add a render subcommand
- CI YAML stays fully declarative
- Local preview: `release plan pr --json | release render comment`

#### 5d. CommentData JSON Schema

Define `CommentDataSchema` as an Effect `Schema.Struct` in `comment-data.ts` for round-trip serialization:

```typescript
const CommentDataSchema = S.Struct({
  plan: Plan,
  github: S.Struct({
    owner: S.String,
    repo: S.String,
    branch: S.String,
    headSha: S.String,
    prNumber: S.Number,
  }),
  releases: S.Array(EnrichedReleaseSchema),
  cascades: S.Array(EnrichedCascadeSchema),
})
```

This enables `--json` output â†’ `render` input with full Schema validation.

---

## File Inventory

### New Files

| File                                                   | Layer | Purpose                                                 |
| ------------------------------------------------------ | ----- | ------------------------------------------------------- |
| `packages/release/src/api/planner/comment-data.ts`     | L1    | CommentData types, enrichPlan(), resolveGitHubContext() |
| `packages/release/src/api/planner/render-comment.ts`   | L2    | Markdown PR comment renderer                            |
| `packages/release/src/api/planner/render-tree.ts`      | L2    | Text tree visualization renderer                        |
| `packages/release/src/api/planner/comment-metadata.ts` | L4    | Parse/embed HTML comment metadata + publish history     |
| `.github/actions/upsert-pr-comment/action.yaml`        | L4    | Reusable PR comment upsert action                       |
| `.github/workflows/publish-pr.yml`                     | L4    | Checkbox-triggered PR publish workflow                  |
| `packages/release/src/cli/commands/render.ts`          | L5    | `render` CLI command (Wave 2)                           |

### Modified Files

| File                                        | Layer | Changes                                                       |
| ------------------------------------------- | ----- | ------------------------------------------------------------- |
| `packages/release/src/api/planner/__.ts`    | L1    | Export new modules                                            |
| `packages/release/src/cli/commands/plan.ts` | L3/L5 | Add `--comment`, `--viz`, `--json`, `--publish-history` flags |
| `.github/workflows/pr.yml`                  | L4    | Replace inline JS with CLI call + composite action            |

### Untouched Files

| File                                                | Reason                                                         |
| --------------------------------------------------- | -------------------------------------------------------------- |
| `packages/release/src/api/planner/models/plan.ts`   | Plan schema unchanged                                          |
| `packages/release/src/api/planner/models/item-*.ts` | Item schemas unchanged                                         |
| `packages/release/src/api/planner/resource.ts`      | plan.json read/write unchanged                                 |
| `packages/release/src/api/planner/presentation.ts`  | Existing CLI text output preserved                             |
| `packages/release/src/api/analyzer/cascade.ts`      | No changes needed (CascadeImpact.triggeredBy already exists)   |
| `packages/release/src/api/analyzer/version.ts`      | No changes needed                                              |
| `packages/release/src/api/explorer/explore.ts`      | Reused but not modified (resolveReleaseTarget may need export) |

---

## Implementation Sequence

### Wave 1

| Step | Layer | Task                                                                              | Dependencies |
| ---- | ----- | --------------------------------------------------------------------------------- | ------------ |
| 1    | L1    | Create `comment-data.ts` with types + `enrichPlan()` + `resolveGitHubContext()`   | â€”            |
| 2    | L2    | Create `render-tree.ts`                                                           | step 1       |
| 3    | L2    | Create `render-comment.ts`                                                        | step 1       |
| 4    | L2    | Create `comment-metadata.ts`                                                      | â€”            |
| 5    | L1    | Update `planner/__.ts` barrel with new exports                                    | steps 1-4    |
| 6    | L3    | Add `--comment`, `--viz`, `--publish-history` flags to `plan` command             | steps 2-3    |
| 7    | L4    | Create `.github/actions/upsert-pr-comment/action.yaml`                            | â€”            |
| 8    | L4    | Refactor `pr.yml` to use CLI + composite action (with publish history extraction) | steps 6-7    |
| 9    | L4    | Create `.github/workflows/publish-pr.yml`                                         | steps 4, 7   |

### Wave 2

| Step | Layer | Task                                | Dependencies                |
| ---- | ----- | ----------------------------------- | --------------------------- |
| 10   | L5    | Add `--json` flag to `plan` command | step 1 (CommentData schema) |
| 11   | L5    | Create `render` CLI command         | step 10                     |
| 12   | L5    | Refactor `pr.yml` to JSON pipeline  | steps 10-11                 |

---

## Reuse Inventory

| Existing                    | Location                                           | Reused For                                  |
| --------------------------- | -------------------------------------------------- | ------------------------------------------- |
| `Str.Builder()`             | `@kitz/core`                                       | All renderer output assembly                |
| `resolveReleaseTarget()`    | `explorer/explore.ts` (local fn â€” may need export) | GitHubContext owner/repo                    |
| `calculateNextVersion()`    | `planner/version.ts`                               | Stable version projection                   |
| `Impact.currentVersion`     | `analyzer/models/impact.ts`                        | Current stable version per package          |
| `Impact.bump`               | `analyzer/models/impact.ts`                        | Bump type per package                       |
| `CascadeImpact.triggeredBy` | `analyzer/models/cascade-impact.ts`                | Cascade "via" attribution                   |
| `Plan.analysis`             | `planner/models/plan.ts`                           | Access embedded Analysis from Plan          |
| `ReleaseCommit.forScope()`  | `analyzer/commit.ts`                               | Extract commit type/description per package |
| `Moniker.moniker` getter    | `@kitz/pkg` moniker.ts                             | Display name for packages                   |

---

## Verification

### Layer 1-3 (CLI)

```bash
# Build first
pnpm turbo run build --filter=@kitz/release

# Generate plan with comment output
GITHUB_PR_NUMBER=129 node packages/release/build/cli/cli.js plan pr --comment

# Generate tree visualization
GITHUB_PR_NUMBER=129 node packages/release/build/cli/cli.js plan pr --viz tree

# Normal plan still works
GITHUB_PR_NUMBER=129 node packages/release/build/cli/cli.js plan pr
```

### Layer 4 (CI)

- Push to PR branch â†’ verify comment is generated correctly via refactored workflow
- Manually edit comment to check a checkbox â†’ verify publish-pr workflow triggers
- Verify comment state transitions: idle â†’ publishing â†’ published/failed

### Layer 5 (JSON pipeline)

```bash
# JSON output
GITHUB_PR_NUMBER=129 node packages/release/build/cli/cli.js plan pr --json > /tmp/plan.json

# Render from JSON
node packages/release/build/cli/cli.js render comment --from-file /tmp/plan.json

# Round-trip equivalence
diff <(plan pr --comment) <(plan pr --json | render comment)
```

### Type checking

```bash
pnpm turbo run check:types --filter=@kitz/release
```
