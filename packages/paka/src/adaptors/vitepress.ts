import { Fs } from '@kitz/fs'
import { Syn } from '@kitz/syn'
import { Match } from 'effect'
import { readFileSync, writeFileSync } from 'fs'
import { mkdirSync } from 'fs'
import { join } from 'path'
import type {
  BodySection,
  Entrypoint,
  Example,
  Export,
  Feature,
  ImportExample,
  InterfaceModel,
  Module,
  SignatureModel,
  TypeExport,
  ValueExport,
} from '../schema.js'

// Convenient alias for markdown utilities
const Md = Syn.Md

/**
 * Configuration for VitePress generation.
 */
export type VitePressConfig = {
  /** Output directory for generated markdown files */
  outputDir: string
  /** Base URL for the docs site */
  baseUrl?: string
  /** GitHub repository URL for source links (e.g., 'https://github.com/owner/repo') */
  githubUrl?: string
  /** Group exports by @category tag (auto-detects if undefined) */
  groupByCategory?: boolean
  /** Optional category ordering for sidebar (defaults to alphabetical with "Other" last) */
  categoryOrder?: string[]
}

/**
 * Derive PascalCase module name from entrypoint path.
 * Examples: './err' → 'Err', './package-manager' → 'PackageManager'
 */
const deriveModuleName = (path: string): string => {
  // Extract stem (remove leading ./)
  const withoutLeadingDot = path.replace(/^\.\//, '')

  // Convert kebab-case to PascalCase
  return withoutLeadingDot
    .split('-')
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join('')
}

/**
 * Detect if a module is a pure wrapper namespace.
 *
 * A pure wrapper is a module with ONLY one export which is a namespace,
 * and the namespace name matches the module name (case-insensitive).
 *
 * Example: `test/$.ts` exports only `Test` namespace → pure wrapper
 *
 * @param moduleName - The module name (e.g., 'Test')
 * @param module - The module to check
 * @returns true if module is a pure wrapper namespace
 */
const isPureWrapperNamespace = (moduleName: string, module: Module): boolean => {
  const exports = module.exports

  // Must have exactly one export
  if (exports.length !== 1) return false

  const singleExport = exports[0]!

  // Must be a value export of type namespace
  if (singleExport._tag !== 'value' || singleExport.type !== 'namespace') {
    return false
  }

  // Namespace name must match module name (case-insensitive)
  return singleExport.name.toLowerCase() === moduleName.toLowerCase()
}

/**
 * Page metadata for a generated page.
 */
type Page = {
  url: string
  filepath: string
  title: string
  entrypoint: Entrypoint
  module: Module
  breadcrumbs: string[]
  pageType?: 'overview' | 'exports' | 'namespace'
}

/**
 * Generation context passed through rendering functions.
 */
type Context = {
  packageName: string
  githubUrl?: string
  breadcrumbs?: string[]
  groupByCategory?: boolean
}

/**
 * Generate VitePress documentation from interface model.
 *
 * @param model - The extracted interface model
 * @param config - VitePress generation configuration
 */
export const generate = (model: InterfaceModel, config: VitePressConfig): void => {
  const { outputDir, githubUrl, groupByCategory, categoryOrder } = config
  const context: Context = {
    packageName: model.name,
    ...(githubUrl ? { githubUrl } : {}),
    ...(groupByCategory !== undefined ? { groupByCategory } : {}),
  }

  // Ensure output directories exist
  mkdirSync(join(outputDir, 'api'), { recursive: true })
  mkdirSync(join(outputDir, '.generated'), { recursive: true })

  // Generate sidebar configuration
  const sidebar = generateSidebar(model, categoryOrder)
  const sidebarContent = `// Auto-generated by Paka - do not edit manually
import type { DefaultTheme } from 'vitepress'

export const apiSidebar: DefaultTheme.SidebarItem[] = ${JSON.stringify(sidebar, null, 2)}
`
  writeFileSync(join(outputDir, '.generated/sidebar.ts'), sidebarContent, 'utf-8')

  // Generate API index page
  const indexContent = generateApiIndex(model)
  writeFileSync(join(outputDir, 'api/index.md'), indexContent, 'utf-8')

  // Generate pages for all modules and namespaces
  const pages = generatePages(model)

  for (const page of pages) {
    const content = generatePageContent(page, context)
    const filepath = join(outputDir, page.filepath)

    // Ensure directory exists
    const dir = filepath.substring(0, filepath.lastIndexOf('/'))
    mkdirSync(dir, { recursive: true })

    writeFileSync(filepath, content, 'utf-8')
  }

  console.log(`Generated ${pages.length} documentation pages and sidebar configuration`)
}

/**
 * Determine which modules are drillable from the main entrypoint.
 * Drillable modules are those re-exported from the main '.' export.
 *
 * @param model - The extracted interface model
 * @returns Set of module names (lowercase) that are drillable from main
 */
const getDrillableModules = (model: InterfaceModel): Set<string> => {
  const drillable = new Set<string>()

  // Find the main entrypoint export file
  const mainExportPath = join(process.cwd(), 'build/exports/index.js')

  try {
    const content = readFileSync(mainExportPath, 'utf-8')

    // Match export statements like: export * from '@kitz/core/arr'
    const exportPattern = /export\s+\*\s+from\s+['"]#([^'"]+)['"]/g
    let match

    while ((match = exportPattern.exec(content)) !== null) {
      const moduleName = match[1]!
      drillable.add(moduleName.toLowerCase())
    }
  } catch (error) {
    // If file doesn't exist or can't be read, assume all modules are drillable
    // This is a safe default for development
    console.warn('Could not read main exports file, assuming all modules are drillable')
    model.entrypoints.forEach((ep: any) => {
      const moduleName = ep.path.replace(/^\.\//, '')
      drillable.add(moduleName.toLowerCase())
    })
  }

  return drillable
}

/**
 * Generate VitePress sidebar configuration from interface model.
 *
 * @param model - The extracted interface model
 * @param categoryOrder - Optional category ordering (defaults to alphabetical)
 * @returns Sidebar items grouped by entrypoint, then by category
 */
export const generateSidebar = (
  model: InterfaceModel,
  categoryOrder?: string[],
): Array<{ text: string; items: Array<{ text: string; link?: string; items?: any[]; collapsed?: boolean }> }> => {
  // Determine which modules are drillable from main
  const drillableModules = getDrillableModules(model)

  // Group entrypoints: drillable from main vs standalone-only
  const mainEntrypoints: any[] = []
  const standaloneEntrypoints: any[] = []

  for (const entrypoint of model.entrypoints) {
    const ep = entrypoint as any
    const moduleName = ep.path.replace(/^\.\//, '').toLowerCase()

    if (drillableModules.has(moduleName)) {
      mainEntrypoints.push(ep)
    } else {
      standaloneEntrypoints.push(ep)
    }
  }

  const sidebar: Array<
    { text: string; items: Array<{ text: string; link?: string; items?: any[]; collapsed?: boolean }> }
  > = []

  // Helper to create sidebar items for a set of entrypoints
  const createSidebarItemsForEntrypoints = (entrypoints: any[]): any[] => {
    const items: any[] = []

    for (const ep of entrypoints) {
      const moduleName = ep.path.replace(/^\.\//, '')
      const displayName = moduleName.charAt(0).toUpperCase() + moduleName.slice(1)

      // Check if this module is a pure wrapper namespace
      const isPureWrapper = isPureWrapperNamespace(displayName, ep.module)

      // Find namespace exports with nested modules
      const namespaceExports = ep.module.namespaceExports
        .map((exp: any) => {
          // For pure wrappers, use '~' instead of namespace name
          const linkSegment = isPureWrapper ? '~' : exp.name.toLowerCase()
          return {
            text: exp.name,
            link: `/api/${moduleName}/${linkSegment}`,
          }
        })
        .sort((a: any, b: any) => a.text.localeCompare(b.text))

      const hasExternalReadme = ep.module.hasExternalReadme

      const item: { text: string; link: string; items?: any[]; collapsed?: boolean } = {
        text: displayName,
        link: `/api/${moduleName}`,
      }

      // Don't add nested items for pure wrappers - they're just namespace wrappers
      if (!isPureWrapper) {
        if (hasExternalReadme) {
          item.items = [
            { text: 'Exports', link: `/api/${moduleName}/exports` },
            ...namespaceExports,
          ]
          item.collapsed = true
        } else if (namespaceExports.length > 0) {
          item.items = namespaceExports
          item.collapsed = true
        }
      }

      items.push(item)
    }

    // Sort items alphabetically
    return items.sort((a, b) => a.text.localeCompare(b.text))
  }

  // Add main entrypoint section
  if (mainEntrypoints.length > 0) {
    const items = createSidebarItemsForEntrypoints(mainEntrypoints)
    sidebar.push({
      text: '/',
      items,
    })
  }

  // Add standalone entrypoint sections
  for (const ep of standaloneEntrypoints) {
    const moduleName = ep.path.replace(/^\.\//, '')

    sidebar.push({
      text: `/${moduleName}`,
      items: createSidebarItemsForEntrypoints([ep]),
    })
  }

  return sidebar
}

/**
 * Generate API index page listing all modules with their namespace trees.
 */
const generateApiIndex = (model: InterfaceModel): string => {
  const modules = model.entrypoints.map((entrypoint) => {
    const ep = entrypoint as any
    // Use instance getters for SimpleEntrypoint, fallback for DrillableNamespaceEntrypoint
    const moduleName = ep._tag === 'SimpleEntrypoint' ? ep.moduleName : deriveModuleName(ep.path)
    const url = `/api/${ep._tag === 'SimpleEntrypoint' ? ep.kebabName : Md.kebab(moduleName)}`
    const description = ep.module.docs?.description
      ? ep.module.docs.description.split('\n\n')[0]!.replace(/\n/g, ' ').trim()
      : ''

    // Find namespace exports
    const namespaceExports = ep.module.namespaceExports
      .sort((a: any, b: any) => a.name.localeCompare(b.name))

    // Build namespace list if any exist
    const namespaceList = namespaceExports.length > 0
      ? '\n\n' + namespaceExports.map((ns: any) => {
        const nsUrl = `/api/${Md.kebab(moduleName)}/${ns.name.toLowerCase()}`
        const nsLink = Md.link(nsUrl, Md.code(ns.name))
        const nsDesc = ns.docs?.description ? ` - ${ns.docs.description}` : ''
        return Md.listItem(`${nsLink}${nsDesc}`)
      }).join('\n')
      : ''

    return `## ${Md.link(url, moduleName)}

${description}${namespaceList}`
  })

  return Md.sections(
    Md.heading(1, 'API Reference'),
    'Browse the complete API documentation for @wollybeard/kit.',
    modules.join('\n\n'),
  )
}

/**
 * Generate all pages from the model.
 */
const generatePages = (model: InterfaceModel): Page[] => {
  const pages: Page[] = []

  for (const entrypoint of model.entrypoints) {
    const ep = entrypoint as any
    // Use instance getters for SimpleEntrypoint, fallback for DrillableNamespaceEntrypoint
    const moduleName = ep._tag === 'SimpleEntrypoint' ? ep.moduleName : deriveModuleName(ep.path)
    const kebabName = ep._tag === 'SimpleEntrypoint' ? ep.kebabName : Md.kebab(moduleName)
    const module = ep.module

    // Check if module description came from external .md file
    if (module.hasExternalReadme) {
      // Split into overview + exports pages

      // Overview page (just README)
      pages.push({
        url: `/api/${kebabName}`,
        filepath: `api/${kebabName}.md`,
        title: moduleName,
        entrypoint,
        module,
        breadcrumbs: [moduleName],
        pageType: 'overview',
      })

      // Exports page (imports + exports, no README)
      pages.push({
        url: `/api/${kebabName}/exports`,
        filepath: `api/${kebabName}/exports.md`,
        title: moduleName,
        entrypoint,
        module,
        breadcrumbs: [moduleName, 'Exports'],
        pageType: 'exports',
      })
    } else {
      // Single page with everything (current behavior)
      pages.push({
        url: `/api/${kebabName}`,
        filepath: `api/${kebabName}.md`,
        title: moduleName,
        entrypoint,
        module,
        breadcrumbs: [moduleName],
      })
    }

    // Namespace pages (recursive)
    pages.push(...generateNamespacePages(entrypoint, module, [moduleName]))
  }

  return pages
}

/**
 * Recursively generate pages for namespace exports.
 */
const generateNamespacePages = (entrypoint: Entrypoint, module: Module, breadcrumbs: string[]): Page[] => {
  const pages: Page[] = []

  const namespaceExports = module.namespaceExports

  // Check if the CURRENT module is a pure wrapper
  // (has single namespace export matching the module name)
  const currentModuleName = breadcrumbs[breadcrumbs.length - 1]
  const isPureWrapper = currentModuleName && isPureWrapperNamespace(currentModuleName, module)

  for (const nsExport of namespaceExports) {
    const newBreadcrumbs = [...breadcrumbs, nsExport.name]

    // Build URL segments
    const urlSegments = newBreadcrumbs.map(Md.kebab)

    // If parent module is a pure wrapper, use '~' instead of namespace name
    if (isPureWrapper) {
      // Replace the namespace name with '~'
      urlSegments[urlSegments.length - 1] = '~'
    }

    const urlPath = urlSegments.join('/')

    if (!nsExport.module) continue

    pages.push({
      url: `/api/${urlPath}`,
      filepath: `api/${urlPath}.md`,
      title: newBreadcrumbs.join('.'),
      entrypoint,
      module: nsExport.module,
      breadcrumbs: newBreadcrumbs,
    })

    // Recursively process nested namespaces
    pages.push(...generateNamespacePages(entrypoint, nsExport.module, newBreadcrumbs))
  }

  return pages
}

/**
 * Check if module should use landing page layout.
 */
const shouldUseLandingPage = (module: Module): boolean => {
  return module.docs?.home !== undefined
}

/**
 * Generate markdown content for a page.
 */
const generatePageContent = (page: Page, context: Context): string => {
  const { entrypoint, module, breadcrumbs, pageType } = page

  // Check for landing page layout first
  if (shouldUseLandingPage(module)) {
    return generateLandingPage(page, context)
  }

  // Handle overview pages (just README)
  if (pageType === 'overview') {
    const description = module.docs?.description || ''
    const guide = module.docs?.guide ? `\n\n${module.docs.guide}` : ''
    return Md.sections(
      Md.heading(1, breadcrumbs.join('.')),
      description + guide,
    )
  }

  // Handle exports pages (skip README)
  if (pageType === 'exports') {
    return generateStandardExportsPage(page, context)
  }

  // Default behavior for single-page modules
  return generateStandardPage(page, context)
}

/**
 * Generate standard doc page (existing logic).
 */
const generateStandardPage = (page: Page, context: Context): string => {
  const { entrypoint, module, breadcrumbs } = page
  const namespaceExports = module.namespaceExports
  const regularExports = module.regularExports

  // Add breadcrumbs to context for namespace usage in examples
  const contextWithBreadcrumbs = { ...context, breadcrumbs }

  const description = module.docs?.description || ''
  const guide = module.docs?.guide ? `\n\n${module.docs.guide}` : ''

  return Md.sections(
    Md.heading(1, breadcrumbs.join('.')),
    description + guide,
    renderImportSection(entrypoint, context.packageName, breadcrumbs),
    namespaceExports.length > 0 ? renderNamespacesSection(namespaceExports, breadcrumbs) : '',
    renderExportsSection(regularExports, contextWithBreadcrumbs),
  )
}

/**
 * Generate standard exports page.
 */
const generateStandardExportsPage = (page: Page, context: Context): string => {
  const { entrypoint, module, breadcrumbs } = page
  const namespaceExports = module.namespaceExports
  const regularExports = module.regularExports

  // Add breadcrumbs to context for namespace usage in examples
  const contextWithBreadcrumbs = { ...context, breadcrumbs }

  return Md.sections(
    Md.heading(1, breadcrumbs.join('.')),
    renderImportSection(entrypoint, context.packageName, [breadcrumbs[0]!]), // Use module name only
    namespaceExports.length > 0 ? renderNamespacesSection(namespaceExports, [breadcrumbs[0]!]) : '',
    renderExportsSection(regularExports, contextWithBreadcrumbs),
  )
}

/**
 * Generate landing page with hero layout.
 */
const generateLandingPage = (page: Page, context: Context): string => {
  const { entrypoint, module, breadcrumbs } = page
  const home = module.docs!.home!

  // Build VitePress frontmatter
  const heroName = home.hero?.name ?? breadcrumbs.join('.')
  const heroText = home.hero?.text ?? ''
  const heroTagline = home.hero?.tagline ?? ''

  const features = home.highlights?.map((h: Feature) => ({
    title: h.title,
    details: h.body,
  })) ?? []

  // Build body content
  const regularExports = module.regularExports
  const contextWithBreadcrumbs = { ...context, breadcrumbs }

  const bodyContent = home.body
    ?.map((section: BodySection) => {
      if (section._tag === 'exports') {
        return renderExportsSection(regularExports, contextWithBreadcrumbs)
      } else {
        return `## ${section.title}\n\n${section.body}`
      }
    })
    .join('\n\n') ?? ''

  // Combine frontmatter + body
  const frontmatterYaml = [
    '---',
    `layout: home`,
    `sidebar: false`,
    '',
    'hero:',
    `  name: ${JSON.stringify(heroName)}`,
    `  text: ${JSON.stringify(heroText)}`,
    `  tagline: ${JSON.stringify(heroTagline)}`,
    '',
    'features:',
    ...features.map((f: { title: string; details: string }) => [
      `  - title: ${JSON.stringify(f.title)}`,
      `    details: ${JSON.stringify(f.details)}`,
    ]).flat(),
    '---',
  ].join('\n')

  return [
    frontmatterYaml,
    '',
    bodyContent,
  ].join('\n')
}

/**
 * Render import examples based on entrypoint pattern.
 */
const renderImportSection = (
  entrypoint: Entrypoint,
  packageName: string,
  breadcrumbs: string[],
): string => {
  const ep = entrypoint as any
  const importExamples = (() => {
    if (ep._tag === 'DrillableNamespaceEntrypoint') {
      return ep.getImportExamples(packageName, breadcrumbs)
    } else {
      return ep.getImportExamples(packageName, ep.path)
    }
  })()

  if (importExamples.length === 0) return ''

  // Single import example - use code fence
  if (importExamples.length === 1) {
    return Md.sections(
      Md.heading(2, 'Import'),
      Md.codeFence(importExamples[0]!.content),
    )
  }

  // Multiple import examples - use code group with tabs
  return Md.sections(
    Md.heading(2, 'Import'),
    Md.codeGroup(
      importExamples.map((example: ImportExample) => ({
        label: example.label,
        code: example.content,
      })),
    ),
  )
}

/**
 * Render namespaces section as a table.
 */
const renderNamespacesSection = (namespaces: Export[], breadcrumbs: string[]): string => {
  const rows = namespaces.map((ns: any) => {
    const nsPath = `/api/${[...breadcrumbs, ns.name].map(Md.kebab).join('/')}`
    const link = Md.link(nsPath, `**${Md.code(ns.name)}**`)
    const desc = ns.docs?.description || '—'
    return `| ${link} | ${desc} |`
  })

  // Build complete table as single string (no blank lines within table)
  const table = [
    '| Namespace | Description |',
    '|-----------|-------------|',
    ...rows,
  ].join('\n')

  return Md.sections(Md.heading(2, 'Namespaces'), table)
}

/**
 * Render all exports grouped by type or category.
 */
const renderExportsSection = (exports: Export[], context: Context): string => {
  // Auto-detect category mode if not explicitly configured
  const shouldGroupByCategory = context.groupByCategory ?? exports.some((e) => e.category != null)

  if (shouldGroupByCategory) {
    // Group by category with seamless interleaving
    const categorized = new Map<string, Export[]>()

    for (const exp of exports) {
      const category = (exp as any).category ?? 'Other'
      const existing = categorized.get(category) ?? []
      categorized.set(category, [...existing, exp])
    }

    // Sort categories alphabetically, with "Other" last
    const sortedCategories = Array.from(categorized.keys()).sort((a, b) => {
      if (a === 'Other') return 1
      if (b === 'Other') return -1
      return a.localeCompare(b)
    })

    // Render each category with seamlessly interleaved exports
    const categorySection = sortedCategories.map((category) => {
      const categoryExports = categorized.get(category) ?? []
      return Md.sections(
        Md.heading(2, category),
        categoryExports.map((e) => renderExport(e, context)).join('\n\n'),
      )
    })

    return Md.sections(...categorySection)
  }

  // Traditional type-based grouping
  const functions = exports.filter((e): e is ValueExport => e._tag === 'value' && e.type === 'function')
  const constants = exports.filter((e): e is ValueExport => e._tag === 'value' && e.type === 'const')
  const classes = exports.filter((e): e is ValueExport => e._tag === 'value' && e.type === 'class')
  const types = exports.filter((e): e is TypeExport => e._tag === 'type')

  return Md.sections(
    functions.length > 0
      ? Md.sections(Md.heading(2, 'Functions'), functions.map((e) => renderExport(e, context)).join('\n\n'))
      : '',
    constants.length > 0
      ? Md.sections(Md.heading(2, 'Constants'), constants.map((e) => renderExport(e, context)).join('\n\n'))
      : '',
    classes.length > 0
      ? Md.sections(Md.heading(2, 'Classes'), classes.map((e) => renderExport(e, context)).join('\n\n'))
      : '',
    types.length > 0
      ? Md.sections(Md.heading(2, 'Types'), types.map((e) => renderExport(e, context)).join('\n\n'))
      : '',
  )
}

/**
 * Escape HTML angle brackets while preserving backtick-wrapped inline code.
 */
const escapeHtmlPreservingCode = (text: string): string => {
  // Extract all backtick-wrapped content and replace with placeholders
  const codeBlocks: string[] = []
  const withPlaceholders = text.replace(/`([^`]+)`/g, (_, code) => {
    codeBlocks.push(code)
    return `%%CODE_${codeBlocks.length - 1}%%`
  })

  // Escape angle brackets in non-code content
  const escaped = withPlaceholders.replace(/</g, '&lt;').replace(/>/g, '&gt;')

  // Restore backtick-wrapped content (unescaped)
  return escaped.replace(/%%CODE_(\d+)%%/g, (_, index) => {
    return `\`${codeBlocks[Number(index)]}\``
  })
}

/**
 * Render a single export.
 */
const renderExport = (exp: Export, context: Context): string => {
  // Deprecation warning with proper link conversion
  const deprecated = exp.deprecated ? Md.deprecation(exp.deprecated) : ''

  // Transform description: normalize whitespace, demote headings, convert links, escape HTML
  // CRITICAL: Must convert double-space separators to newlines BEFORE demoting headings,
  // since demoteHeadings requires actual line breaks to match ^## patterns
  const transformMarkdown = (text: string) =>
    escapeHtmlPreservingCode(
      Md.demoteHeadings(
        Md.convertJSDocLinks(
          text
            .replace(/  /g, '\n\n') // Convert double-space paragraph separators to newlines FIRST
            .replace(/ - /g, '\n- '), // Convert list item separators to proper markdown list items
        ),
        2, // Demote headings AFTER newlines are added (exports are h3, so description content becomes h4+)
      )
        // Wrap list items that start with code-like patterns in backticks
        .replace(/^- (\[\[.*?\]\]|\{[^}]+\})/gm, '- `$1`'),
    )

  const description = exp.docs?.description ? transformMarkdown(exp.docs.description) : ''
  const guide = exp.docs?.guide ? `\n\n${transformMarkdown(exp.docs.guide)}` : ''

  const examples = exp.examples.length > 0
    ? `**Examples:**\n\n${exp.examples.map((ex) => renderExample(ex, exp.name, context)).join('\n\n')}`
    : ''

  // Build heading with type icon (using backticks for monospace)
  const typeIcon = exp.typeIcon
  // Source link inline with heading - icon-only, right-aligned
  const sourceLink = context.githubUrl && exp.sourceLocation
    ? `<SourceLink inline href="${context.githubUrl}/blob/main/${exp.sourceLocation.file}#L${exp.sourceLocation.line}" />`
    : ''

  // Normalize type icon for anchor ID (handles duplicate names with different types)
  const typeIconNormalized = typeIcon.toLowerCase().replace('∩', 'intersection')

  // Generate unique anchor ID: type-icon-prefix + kebab-case-name + line-number
  // Line number is included to handle function overloads (same name, different signatures)
  const anchorId = `${typeIconNormalized}-${Md.kebab(exp.name)}-${exp.sourceLocation.line}`

  const heading = Md.heading(
    3,
    `<span style="opacity: 0.6; font-weight: normal; font-size: 0.85em;">\`[${typeIcon}]\`</span> ${
      Md.code(exp.name)
    }${sourceLink} {#${anchorId}}`,
  )

  // Render signature - use simple signature if available, with full signature in toggle
  let signatureSection: string
  let signatureDetails: string

  if (exp.signatureSimple) {
    // Simple signature as primary
    const simpleSignatureText = renderSignature(exp.signatureSimple)
    const fullSignatureText = renderSignature(exp.signature)

    signatureSection = Md.sections(
      Md.codeFence(simpleSignatureText),
      '<details>',
      '<summary>Full Signature</summary>',
      '',
      Md.codeFence(fullSignatureText),
      '',
      '</details>',
    )

    // Use simple signature for parameter docs
    signatureDetails = renderSignatureDetails(exp.signatureSimple)
  } else {
    // No simple signature - render normally
    const signatureText = renderSignature(exp.signature)
    signatureSection = Md.codeFence(signatureText)
    signatureDetails = renderSignatureDetails(exp.signature)
  }

  return Md.sections(
    heading,
    signatureSection,
    signatureDetails,
    deprecated,
    description + guide,
    examples,
  )
}

/**
 * Render signature details (parameter descriptions, return documentation, throws).
 */
const renderSignatureDetails = (sig: SignatureModel): string => {
  return Match.value(sig).pipe(
    Match.tags({
      FunctionSignatureModel: (fnSig) => {
        // Collect documentation from all overloads
        const allParams = new Map<string, string>()
        let returnDoc: string | undefined
        const allThrows: string[] = []

        for (const overload of fnSig.overloads) {
          // Collect parameter descriptions
          for (const param of overload.parameters) {
            if (param.description && !allParams.has(param.name)) {
              allParams.set(param.name, param.description)
            }
          }

          // Use first non-empty return doc
          if (overload.returnDoc && !returnDoc) {
            returnDoc = overload.returnDoc
          }

          // Collect all throws
          for (const throwsDesc of overload.throws) {
            if (!allThrows.includes(throwsDesc)) {
              allThrows.push(throwsDesc)
            }
          }
        }

        // Build sections
        const sections: string[] = []

        if (allParams.size > 0) {
          const paramsList = Array.from(allParams.entries())
            .map(([name, desc]) => `- \`${name}\` - ${desc}`)
            .join('\n')
          sections.push(`**Parameters:**\n\n${paramsList}`)
        }

        if (returnDoc) {
          sections.push(`**Returns:** ${returnDoc}`)
        }

        if (allThrows.length > 0) {
          const throwsList = allThrows.map((desc) => `- ${desc}`).join('\n')
          sections.push(`**Throws:**\n\n${throwsList}`)
        }

        return sections.length > 0 ? sections.join('\n\n') : ''
      },
      BuilderSignatureModel: (builderSig) => {
        // Render docs for entry point
        const entryPoint = builderSig.entryPoint
        const sections: string[] = []

        // Entry point parameters
        if (entryPoint.parameters.some((p) => p.description)) {
          const paramsList = entryPoint.parameters
            .filter((p) => p.description)
            .map((p) => `- \`${p.name}\` - ${p.description}`)
            .join('\n')
          sections.push(`**Parameters:**\n\n${paramsList}`)
        }

        // Entry point return doc
        if (entryPoint.returnDoc) {
          sections.push(`**Returns:** ${entryPoint.returnDoc}`)
        }

        // Entry point throws
        if (entryPoint.throws.length > 0) {
          const throwsList = entryPoint.throws.map((desc) => `- ${desc}`).join('\n')
          sections.push(`**Throws:**\n\n${throwsList}`)
        }

        return sections.length > 0 ? sections.join('\n\n') : ''
      },
      ClassSignatureModel: (classSig) => {
        const sections: string[] = []

        // Constructor documentation
        if (classSig.ctor) {
          // Constructor parameters
          if (classSig.ctor.parameters.some((p) => p.description)) {
            const paramsList = classSig.ctor.parameters
              .filter((p) => p.description)
              .map((p) => `- \`${p.name}\` - ${p.description}`)
              .join('\n')
            sections.push(`**Constructor Parameters:**\n\n${paramsList}`)
          }

          // Constructor throws
          if (classSig.ctor.throws.length > 0) {
            const throwsList = classSig.ctor.throws.map((desc) => `- ${desc}`).join('\n')
            sections.push(`**Constructor Throws:**\n\n${throwsList}`)
          }
        }

        // Property descriptions
        const propsWithDesc = classSig.properties.filter((p) => p.description)
        if (propsWithDesc.length > 0) {
          const propsList = propsWithDesc
            .map((p) => `- \`${p.name}\` - ${p.description}`)
            .join('\n')
          sections.push(`**Properties:**\n\n${propsList}`)
        }

        return sections.length > 0 ? sections.join('\n\n') : ''
      },
      TypeSignatureModel: () => '',
      ValueSignatureModel: () => '',
    }),
    Match.exhaustive,
  )
}

/**
 * Render type parameters to string (e.g., "<T, U extends string>").
 */
const renderTypeParameters = (typeParams: readonly typeof import('../schema.js').TypeParameter.Type[]): string => {
  if (typeParams.length === 0) return ''

  const rendered = typeParams.map((tp) => {
    let text = tp.name
    if (tp.constraint) text += ` extends ${tp.constraint}`
    if (tp.default) text += ` = ${tp.default}`
    return text
  }).join(', ')

  return `<${rendered}>`
}

/**
 * Render function parameters to string (e.g., "a: number, b?: string").
 */
const renderParameters = (params: readonly typeof import('../schema.js').Parameter.Type[]): string => {
  return params.map((param) => {
    let text = ''
    if (param.rest) text += '...'
    text += param.name
    if (param.optional) text += '?'
    text += `: ${param.type}`
    if (param.defaultValue) text += ` = ${param.defaultValue}`
    return text
  }).join(', ')
}

/**
 * Render SignatureModel to string for display in code fence.
 */
const renderSignature = (sig: SignatureModel): string => {
  return Match.value(sig).pipe(
    Match.tags({
      FunctionSignatureModel: (fnSig) => {
        // Render all overloads
        return fnSig.overloads.map((overload) => {
          const typeParams = renderTypeParameters(overload.typeParameters)
          const params = renderParameters(overload.parameters)
          return `${typeParams}(${params}): ${overload.returnType}`
        }).join('\n')
      },
      BuilderSignatureModel: (builderSig) => {
        // Render builder entry point
        const entryPoint = builderSig.entryPoint
        const typeParams = renderTypeParameters(entryPoint.typeParameters)
        const params = renderParameters(entryPoint.parameters)
        let result = `${typeParams}(${params}): ${builderSig.typeName}\n`

        // Render chainable methods
        if (builderSig.chainableMethods.length > 0) {
          result += '\n// Chainable methods:\n'
          for (const method of builderSig.chainableMethods) {
            // Render all overloads for this method
            for (const overload of method.overloads) {
              const methodTypeParams = renderTypeParameters(overload.typeParameters)
              const methodParams = renderParameters(overload.parameters)
              result += `  .${method.name}${methodTypeParams}(${methodParams}): ${builderSig.typeName}\n`
            }
          }
        }

        // Render terminal methods
        if (builderSig.terminalMethods.length > 0) {
          result += '\n// Terminal methods:\n'
          for (const method of builderSig.terminalMethods) {
            // Render all overloads for this method
            for (const overload of method.overloads) {
              const methodTypeParams = renderTypeParameters(overload.typeParameters)
              const methodParams = renderParameters(overload.parameters)
              result += `  .${method.name}${methodTypeParams}(${methodParams}): ${overload.returnType}\n`
            }
          }
        }

        // Render transform methods
        if (builderSig.transformMethods.length > 0) {
          result += '\n// Transform methods:\n'
          for (const method of builderSig.transformMethods) {
            // Render all overloads for this method
            for (const overload of method.overloads) {
              const methodTypeParams = renderTypeParameters(overload.typeParameters)
              const methodParams = renderParameters(overload.parameters)
              const returnType = method.transformsTo || overload.returnType
              result += `  .${method.name}${methodTypeParams}(${methodParams}): ${returnType}\n`
            }
          }
        }

        return result
      },
      ClassSignatureModel: (classSig) => {
        let result = 'class {\n'

        // Render constructor
        if (classSig.ctor) {
          const typeParams = renderTypeParameters(classSig.ctor.typeParameters)
          const params = renderParameters(classSig.ctor.parameters)
          result += `  constructor${typeParams}(${params})\n`
        }

        // Render properties
        if (classSig.properties.length > 0) {
          result += '\n  // Properties\n'
          for (const prop of classSig.properties) {
            let propLine = '  '
            if (prop.static) propLine += 'static '
            if (prop.readonly) propLine += 'readonly '
            propLine += prop.name
            if (prop.optional) propLine += '?'
            propLine += `: ${prop.type}\n`
            result += propLine
          }
        }

        // Render methods
        if (classSig.methods.length > 0) {
          result += '\n  // Methods\n'
          for (const method of classSig.methods) {
            for (const overload of method.overloads) {
              let methodLine = '  '
              if (method.static) methodLine += 'static '
              const typeParams = renderTypeParameters(overload.typeParameters)
              const params = renderParameters(overload.parameters)
              methodLine += `${method.name}${typeParams}(${params}): ${overload.returnType}\n`
              result += methodLine
            }
          }
        }

        result += '}'
        return result
      },
      TypeSignatureModel: (typeSig) => typeSig.text,
      ValueSignatureModel: (valSig) => valSig.type,
    }),
    Match.exhaustive,
  )
}

/**
 * Render a code example with Twoslash.
 */
const renderExample = (example: any, exportName: string, context: Context): string => {
  // Don't wrap title in bold - it may already contain markdown formatting (e.g., headings)
  const title = example.title || ''

  let code = example.code

  // Transform code to use namespace notation
  if (context.breadcrumbs && context.breadcrumbs.length > 0) {
    const namespace = context.breadcrumbs.join('.')
    const namespaceCall = `${namespace}.${exportName}`
    const topLevelModule = context.breadcrumbs[0]

    // Replace standalone function calls with namespace calls
    const regex = new RegExp(`(?<!\\.)\\b${exportName}(?=\\(|\\.)`, 'g')
    code = code.replace(regex, namespaceCall)

    // Add Twoslash setup (import + @noErrors directive)
    const hasImports = code.includes('import ')
    if (topLevelModule) {
      if (!hasImports) {
        const importStatement = `import { ${topLevelModule} } from '${context.packageName}/${Md.kebab(topLevelModule)}'`
        code = `// @noErrors\n${importStatement}\n// ---cut---\n${code}`
      } else {
        code = `// @noErrors\n${code}`
      }
    }
  }

  return Md.sections(title, Md.codeFence(code, example.language, 'twoslash'))
}
